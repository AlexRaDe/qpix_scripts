import sys
import os
import math
import subprocess
import time

vref = 1.007
dac_addr = "0x48"
step_size = 0.0001  # Increment step for v_set
start_vset = 0.7765  # Starting value for v_set
max_vset = vref  # Maximum value for v_set
max_iterations = 2000  # Maximum number of sweeps per channel
zero_count_threshold = 1  # Stop sweeping if reset counts are zero for this many iterations

# External script to measure reset counts
run_sampling = "run_sampling.py"

def run_sampling_and_parse():
    """
    Run the external script and parse the output file to get reset counts for all channels.
    Returns a dictionary with channel numbers as keys and average counts as values.
    """
    try:
        # Run the external script
        subprocess.run(["python3", run_sampling], check=True)

        # Path to the output file generated by run_sampling.py
        output_file = 'outputs/DAC_sweep_alex.txt'

        # Parse the output file
        reset_counts = {}
        with open(output_file, 'r') as f:
            lines = f.readlines()

        # Extract reset counts for all channels
        for i, line in enumerate(lines):
            if line.strip().startswith('Channel'):
                # Extract the channel number
                channel = int(line.split()[1]) - 8
                # Extract the Avg Count from the next line
                avg_count_line = lines[i + 2]
                avg_count = float(avg_count_line.split(':')[1].strip())
                reset_counts[channel] = avg_count

        return reset_counts

    except Exception as e:
        print(f"Error running sampling or parsing output file: {e}")
        return None

def set_dac_all_channels(vset, frozen_channels):
    """
    Set the DAC value for all unfrozen channels to the given v_set.
    """
    steps = vref / 4096
    if vset <= 0:
        counts = 0x000
    elif vset >= vref:
        counts = 0xfff
    else:
        counts = math.floor(vset / steps)

    # Format counts for DAC
    counts_formatted = str.format('{:04X}', counts << 4)
    msn = counts_formatted[0:2]
    lsn = counts_formatted[2:4]

    # Send command for all unfrozen channels
    for channel in range(8):  # Channels 0-7
        if channel not in frozen_channels:
            command = f'i2cset -y 1 {dac_addr} 0x0{channel} 0x{msn} 0x{lsn} i'
            print(f"Sending command for channel {channel + 8}: {command} {vset}")
            os.system(command)

def sweep_all_channels():
    """
    Sweep through v_set values for all channels simultaneously to find the optimal settings.
    """
    vset = start_vset
    frozen_channels = set()  # Channels that have found their optimal v_set
    optimal_vsets = {}
    iteration_counts = {channel: 0 for channel in range(8)}  # Track iterations per channel
    zero_count_tracker = {channel: 0 for channel in range(8)}  # Track consecutive zero counts per channel
    tolerance = 2

    print("Sweeping channels")

    while vset <= max_vset and len(frozen_channels) < 7:
        # Set v_set for all unfrozen channels
        set_dac_all_channels(vset, frozen_channels)
        time.sleep(0.1)  # Allow time for the DAC to stabilize

        # Run sampling and parse the results
        reset_counts = run_sampling_and_parse()
        if reset_counts is None:
            print("Failed to retrieve reset counts. Exiting.")
            sys.exit(1)

        # Check reset counts for all channels
        for channel, reset_count in reset_counts.items():
            if channel not in frozen_channels:
                print(f"Channel {channel + 8}, v_set {vset:.6f}: Reset counts = {reset_count}")
                iteration_counts[channel] += 1  # Increment iteration count for the channel

                # Stop condition: Reset count equals 10
                if 10 - tolerance <= reset_count <= 10 + tolerance:
                    print(f"Optimal v_set found for channel {channel + 8}: {vset:.6f}")
                    frozen_channels.add(channel)
                    optimal_vsets[channel] = vset

                # Stop condition: Maximum iterations reached
                elif iteration_counts[channel] >= max_iterations:
                    print(f"Maximum iterations reached for channel {channel}. Stopping sweep.")
                    frozen_channels.add(channel)

                # Stop condition: Consecutive zero counts
                elif reset_count == 0:
                    zero_count_tracker[channel] += 1
                    if zero_count_tracker[channel] >= zero_count_threshold:
                        print(f"Channel {channel} has returned zero counts for {zero_count_tracker[channel]} consecutive iterations. Stopping sweep.")
                        frozen_channels.add(channel)
                else:
                    zero_count_tracker[channel] = 0  # Reset zero count tracker if non-zero counts are found

        # Increment v_set for unfrozen channels
        vset += step_size

    # Print final results
    for channel in range(8):
        if channel in optimal_vsets:
            print(f"Channel {channel + 8}: Optimal v_set = {optimal_vsets[channel]:.6f}")
        else:
            print(f"Channel {channel + 8}: No optimal v_set found.")

# Run the sweep
sweep_all_channels()
