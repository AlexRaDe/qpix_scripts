# Parallel binary search DAC sweep script

#!/usr/bin/env python3

import sys
import os
import math
import subprocess
import time
from concurrent.futures import ThreadPoolExecutor

# Configuration parameters
vref = 1.007
dac_addr = "0x48"
start_vset = 0.775  # Starting value for v_set
max_vset = vref     # Maximum value for v_set
max_iterations = 100  # Maximum number of iterations per channel
zero_count_threshold = 10  # Stop if zero counts for this many consecutive measurements
tolerance = 2       # Tolerance around target count of 10
voltage_tolerance = 0.0001  # Voltage resolution for binary search

# External script to measure reset counts
run_sampling = "run_sampling.py"

def run_sampling_and_parse():
    """
    Run the external script and parse the output file to get reset counts for all channels.
    Returns a dictionary with channel numbers as keys and average counts as values.
    """
    try:
        # Run the external script
        subprocess.run(["python3", run_sampling], check=True)

        # Path to the output file generated by run_sampling.py
        output_file = 'outputs/DAC_sweep_alex.txt'

        # Parse the output file
        reset_counts = {}
        with open(output_file, 'r') as f:
            lines = f.readlines()

        # Extract reset counts for all channels
        for i, line in enumerate(lines):
            if line.strip().startswith('Channel'):
                # Extract the channel number
                channel = int(line.split()[1]) - 8
                # Extract the Avg Count from the next line
                avg_count_line = lines[i + 2]
                avg_count = float(avg_count_line.split(':')[1].strip())
                reset_counts[channel] = avg_count

        return reset_counts

    except Exception as e:
        print(f"Error running sampling or parsing output file: {e}")
        return None

def set_dac_single_channel(channel, vset):
    """
    Set the DAC value for a single channel to the given v_set.
    """
    steps = vref / 4096
    if vset <= 0:
        counts = 0x000
    elif vset >= vref:
        counts = 0xfff
    else:
        counts = math.floor(vset / steps)

    # Format counts for DAC
    counts_formatted = str.format('{:04X}', counts << 4)
    msn = counts_formatted[0:2]
    lsn = counts_formatted[2:4]

    # Send command for the specific channel
    command = f'i2cset -y 1 {dac_addr} 0x0{channel} 0x{msn} 0x{lsn} i'
    print(f"Sending command for channel {channel + 8}: {command} {vset:.6f}V")
    os.system(command)

def binary_search_channel(channel, min_v, max_v):
    """
    Perform binary search for optimal vset on a single channel.
    Returns optimal vset or None if not found.
    """
    zero_count_streak = 0
    iterations = 0
    best_v = None
    best_diff = float('inf')
   
    while (max_v - min_v) > voltage_tolerance and iterations < max_iterations:
        mid_v = (min_v + max_v) / 2
        set_dac_single_channel(channel, mid_v)
        time.sleep(0.05)  # Reduced stabilization time
       
        reset_counts = run_sampling_and_parse()
        if reset_counts is None:
            iterations += 1
            continue
           
        count = reset_counts.get(channel, 0)
        iterations += 1
       
        # Track best solution found so far
        current_diff = abs(count - 10)
        if current_diff < best_diff:
            best_diff = current_diff
            best_v = mid_v
       
        # Check for zero counts
        if count == 0:
            zero_count_streak += 1
            if zero_count_streak >= zero_count_threshold:
                print(f"Channel {channel + 8}: Too many zero counts, stopping search")
                return best_v
            max_v = mid_v  # Search lower voltages
            continue
        else:
            zero_count_streak = 0
           
        # Binary search logic
        if count < 10 - tolerance:
            min_v = mid_v  # Need higher voltage
        elif count > 10 + tolerance:
            max_v = mid_v  # Need lower voltage
        else:
            print(f"Channel {channel + 8}: Found optimal v_set at {mid_v:.6f}V")
            return mid_v  # Found optimal voltage
           
    print(f"Channel {channel + 8}: Best v_set found at {best_v:.6f}V (diff: {best_diff:.2f})")
    return best_v

def optimized_sweep():
    """
    Optimized sweep using binary search for each channel in parallel.
    """
    optimal_vsets = {}
   
    def process_channel(channel):
        print(f"\n=== Starting binary search for channel {channel + 8} ===")
        optimal_v = binary_search_channel(channel, start_vset, max_vset)
        if optimal_v is not None:
            optimal_vsets[channel] = optimal_v
            # Set final value
            set_dac_single_channel(channel, optimal_v)
        return channel
   
    # Process channels in parallel (adjust max_workers based on your system)
    print("\n==== Starting optimized sweep ====")
    print(f"Search range: {start_vset:.6f}V to {max_vset:.6f}V")
    print(f"Target counts: 10 Â± {tolerance}")
    print(f"Voltage tolerance: {voltage_tolerance:.6f}V\n")
   
    with ThreadPoolExecutor(max_workers=8) as executor:
        for channel in executor.map(process_channel, range(8)):
            pass  # Just wait for completion
   
    # Print final results
    print("\n==== Final Results ====")
    for channel in range(8):
        if channel in optimal_vsets:
            print(f"Channel {channel + 8}: Optimal v_set = {optimal_vsets[channel]:.6f}V")
        else:
            print(f"Channel {channel + 8}: No optimal v_set found")
   
    return optimal_vsets

if __name__ == "__main__":
    optimized_sweep()
